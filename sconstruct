
from SCons import Errors
import subprocess
import time
import os
import re

NAME = 'tsym'
LIBNAME = 'lib%s' % NAME
DEFAULT_PREFIX = '/usr/local'
DEFAULT_BUILDDIR = './build'
TEST_EXEC = 'runtests'
PUBLIC_HEADER = ['globals', 'matrix', 'var', 'vector', 'version', 'buildinfo']
CONFIG_FILE = 'config.py'

def publicHeaderList():
    def path(header):
        return os.path.join(env['BUILDDIR'], 'src', header + '.h')

    return  [path(header) for header in PUBLIC_HEADER]

def includeGuard(fp, filename = ''):
    if not filename:
        fp.write('\n#endif\n')
    else:
        baseFilename = os.path.splitext(os.path.basename(filename))[0]
        token = ('%s_%s_H' % (NAME, baseFilename)).upper()
        fp.write('#ifndef %s\n#define %s\n\n' % (token, token))

def writeLibHeader(target, source, env):
    filename = str(target[0])

    with open(filename, 'w') as fp:
        includeGuard(fp, filename)

        for header in publicHeaderList():
            fp.write('#include "%s"\n' % os.path.basename(header))

        includeGuard(fp)

def git(*args):
    if os.path.isdir('.git'):
        return subprocess.check_output(['git'] + list(args))
    else:
        return ''

def getRepoInfo():
    branch = git('rev-parse', '--abbrev-ref', 'HEAD').strip()
    commit = git('log', '--pretty=format:%h', '-n 1')
    tag = git('name-rev', '--name-only', '--tags', 'HEAD').strip()
    stable = tag.startswith('v')

    return branch, commit, stable

def writeBuildInfoHeader(target, source, env):
    branch, commit, stable = getRepoInfo()
    timeStr = time.strftime("%H:%M, %a %b %d, %Y", time.localtime())
    filename = str(target[0])
    info = []

    if branch and commit:
        info += [('COMMIT', commit), ('BRANCH', branch)]

        if not stable:
            info.append(('UNSTABLE', None))

    info += [('CPP_COMPILER', env['CXX'] + ' ' + env['CXXVERSION']),
            ('CPP_FLAGS', env['CCFLAGS'] + env['CXXFLAGS']),
            ('C_COMPILER', env['CC'] + ' ' + env['CCVERSION']),
            ('C_FLAGS', env['CCFLAGS'] + env['CFLAGS']),
            ('PARSER_GENERATOR', env['YACC']), ('LEXICAL_ANALYZER', env['LEX']),
            ('BUILD_OS', ' '.join(os.uname())), ('BUILD_DATE', timeStr)]

    with open(str(target[0]), 'w') as fp:
        includeGuard(fp, filename)

        for pair in info:
            line = '#define %s_' % NAME.upper() + pair[0]
            line += ' "%s"\n' % str(pair[1]) if pair[1] else '\n'
            fp.write(line)

        includeGuard(fp)

def buildDir(self, *paths):
    return os.path.join(self['BUILDDIR'], *paths)

def libExistance(target, source, env):
    filename = str(env['LIBTARGET'][0])
    if not os.path.isfile(filename):
        raise Errors.StopError('%s not found. Compile it before tests or installation.' % filename)

SetOption('num_jobs', 4)

variables = Variables(CONFIG_FILE)
variables.AddVariables(
        ('CXX', 'C++ compiler', Environment()['CXX']),
        ('CXXFLAGS', 'C++ compiler flags'),
        ('CC', 'C compiler', Environment()['CC']),
        ('CFLAGS', 'C compiler flags'),
        BoolVariable('RELEASE', 'Build with  predefined release flags', 1),
        BoolVariable('DEBUG', 'Build with predefined debug flags (overrides RELEASE)', 0),
        BoolVariable('COVERAGE', 'Add compiler flags for test coverage meta data', 0),
        BoolVariable('UTF8', 'Enable utf-8 printing by default', 1),
        PathVariable('BUILDDIR', 'Directory for compilation targets', DEFAULT_BUILDDIR),
        PathVariable('PREFIX', 'Installation prefix', DEFAULT_PREFIX))

env = Environment(variables = variables)

if variables.unknown:
    raise Errors.StopError('Variables %s are invalid' % ' '.join(variables.unknown.keys()))

if env['DEBUG']:
    env['RELEASE'] = False

for key in ('CC', 'CXX', 'CFLAGS', 'CXXFLAGS'):
    if key in os.environ.keys() and not key in env.Dictionary().keys():
        env[key] = os.environ.get(key)

env.AddMethod(buildDir)

if env['RELEASE']:
    env.Append(CPPDEFINES = 'NDEBUG')
else:
    env.Append(CPPDEFINES = [NAME.upper() + '_DEBUG_STRINGS'])

if not env['UTF8']:
    env.Append(CPPDEFINES = [NAME.upper() + '_WITHOUT_UTF8'])

if not env['CFLAGS']:
    env.Append(CFLAGS = ['-pedantic', '-Wall', '-Wextra', '-Wno-sign-compare', '-Wno-unused-label',
        '-Wno-unused-function', '-Wno-unneeded-internal-declaration'])
    if env['RELEASE']:
        env.Append(CFLAGS = '-O2')
    elif env['DEBUG']:
        env.Append(CFLAGS = ['-O0', '-g3', '-ggdb'])

if not env['CXXFLAGS']:
    env.Append(CXXFLAGS = ['-std=c++98', '-pedantic', '-Wall', '-Wextra', '-Werror=conversion'])
    if env['RELEASE']:
        env.Append(CXXFLAGS = '-O2')
    elif env['DEBUG']:
        env.Append(CXXFLAGS = ['-O0', '-g3', '-ggdb'])

libEnv = env.Clone()
testEnv = env.Clone()

libEnv.Replace(BUILDDIR = env.buildDir('src'))
testEnv.Replace(BUILDDIR = env.buildDir('test'))

libEnv.Append(BUILDERS = {
    'BuildInfo': Builder(action = writeBuildInfoHeader),
    'LibHeader': Builder(action = writeLibHeader)
    })

libEnv.VariantDir(libEnv.buildDir(), 'src')
libEnv.Append(CPPPATH = libEnv.buildDir())
libEnv.Append(YACCFLAGS = '-d')

buildInfoHeader = libEnv.BuildInfo(libEnv.buildDir('buildinfo.h'), None)
libHeader = libEnv.LibHeader(libEnv.buildDir('%s.h' % NAME), None)

scanner = libEnv.buildDir('scanner.c')
parser = libEnv.buildDir('parser.c')
libEnv.CFile(scanner, 'src/scanner.l')
libEnv.CFile(parser, 'src/parser.y')

testEnv.VariantDir(testEnv.buildDir(), 'test')
testEnv.Append(CPPPATH = [libEnv.buildDir(), testEnv.buildDir()])
testEnv.Append(LIBS = ['CppUTest', 'tsym', 'trlog'])
testEnv.Append(RPATH = env.buildDir())
testEnv.Append(LIBPATH = env.buildDir())

libTarget = libEnv.SharedLibrary(env.buildDir(LIBNAME),
    Glob(libEnv.buildDir('*.cpp')) + [scanner, parser])

if libEnv['COVERAGE']:
    libEnv.Append(CXXFLAGS = ['--coverage'])
    libEnv.AppendUnique(LIBS = 'gcov')
    Clean(libTarget, Glob(libEnv.buildDir('*.gcno')) + Glob(libEnv.buildDir('*.gcda')))

testTarget = testEnv.Program(env.buildDir(TEST_EXEC), Glob(testEnv.buildDir('*.cpp')))

# The following lines ensures that library and tests can be built with different CXXFLAGS. Due to
# the hard-coded removal of the dependency, its local existance has to be checked, otherwise the
# test executable might be linked against a globally installed version of the library.
testEnv.Append(LIBTARGET = libTarget)
testEnv.Ignore(testTarget, testEnv['LIBTARGET'])
testEnv.AddPreAction(testTarget, libExistance)

includeDir = os.path.join(env['PREFIX'], 'include')
headerTargetDir = os.path.join(includeDir, NAME)
libDir = os.path.join(env['PREFIX'], 'lib')
libPath = os.path.join(libDir, LIBNAME + Environment().subst('$SHLIBSUFFIX'))

installLib = libEnv.InstallAs(libPath, libTarget)
installHeader = libEnv.Install(headerTargetDir, [publicHeaderList(), libHeader])

for target in installHeader:
    libEnv.AddPostAction(target, Chmod('$TARGET', 0644))
for target in [env['PREFIX'], headerTargetDir, libDir, includeDir, installLib]:
    libEnv.AddPostAction(target, Chmod('$TARGET', 0755))

uninstall = libEnv.Command('uninstall', None, Delete(FindInstalledFiles()))
libEnv.AddPostAction(uninstall, Delete(headerTargetDir))

Default([libTarget, testTarget, buildInfoHeader])
AlwaysBuild(buildInfoHeader)
Alias('lib', [libTarget, buildInfoHeader])
Alias('test', testTarget)
Alias('install', [installHeader, installLib])

Help("""
Build targets:\n
    [none]           shared library and unit tests
    'lib'            shared library only
    'test'           unit tests only
    'install'        install library and headers
    'uninstall'      deinstall library and headers

Build options, possibly set in %s, or by environment (compiler and their flags):
%s""" % (CONFIG_FILE, variables.GenerateHelpText(env)), append = False)

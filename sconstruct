
from SCons import Errors
import subprocess
import time
import os
import re

NAME = 'tsym'
LIBNAME = 'lib%s' % NAME
DEFAULT_PREFIX = '/usr/local'
DEFAULT_BUILDDIR = 'build'
TEST_EXEC = 'runtests'
PUBLIC_HEADER = ['baseptr', 'globals', 'int', 'matrix', 'number', 'solver', 'stringtovar', 'var',
        'vector', 'config', 'buildinfo']

def publicHeaderList():
    def path(header):
        return os.path.join(GetOption('buildDir'), 'src', header + '.h')

    return  [path(header) for header in PUBLIC_HEADER]

def includeGuard(fp, filename = ''):
    if not filename:
        fp.write('\n#endif\n')
    else:
        baseFilename = os.path.splitext(os.path.basename(filename))[0]
        token = ('%s_%s_H' % (NAME, baseFilename)).upper()
        fp.write('#ifndef %s\n#define %s\n\n' % (token, token))

def writeLibHeader(target, source, env):
    filename = str(target[0])

    with open(filename, 'w') as fp:
        includeGuard(fp, filename)

        for header in publicHeaderList():
            fp.write('#include "%s"\n' % os.path.basename(header))

        includeGuard(fp)

def writeConfigHeader(target, source, env):
    filename = str(target[0])

    with open(filename, 'w') as fp:
        includeGuard(fp, filename)

        if env['WITH_DEBUG_STRINGS']:
            fp.write('#define %s_%s\n' % (NAME.upper(), 'DEBUG_STRINGS'))
        if env['WITH_UTF8']:
            fp.write('#define %s_%s\n' % (NAME.upper(), 'WITH_UTF8'))

        includeGuard(fp)

def git(*args):
    return subprocess.check_output(['git'] + list(args))

def getRepoInfo():
    branch = git('rev-parse', '--abbrev-ref', 'HEAD').strip()
    commit = git('log', '--pretty=format:%h', '-n 1')
    tag = git('name-rev', '--name-only', '--tags', 'HEAD').strip()
    if tag != 'undefined' and tag.startswith('v'):
        major, minor = int(tag[1]), int(tag[3])
        tag = None
    else:
        major, minor = 0, 0
    return branch, major, minor, commit

def writeBuildInfoHeader(target, source, env):
    branch, major, minor, commit = getRepoInfo()
    timeStr = time.strftime("%H:%M, %a %b %d, %Y", time.localtime())
    filename = str(target[0])

    info = [('VERSION_MAJOR %d' % major, None), ('VERSION_MINOR %d' % minor, None),
            ('COMMIT', commit), ('BRANCH', branch),
            ('CPP_COMPILER', env['CXX'] + ' ' + env['CXXVERSION']),
            ('CPP_FLAGS', env['CCFLAGS'] + env['CXXFLAGS']),
            ('C_COMPILER', env['CC'] + ' ' + env['CCVERSION']),
            ('C_FLAGS', env['CCFLAGS'] + env['CFLAGS']),
            ('PARSER_GENERATOR', env['YACC']), ('LEXICAL_ANALYZER', env['LEX']),
            ('BUILD_OS', ' '.join(os.uname())), ('BUILD_DATE', timeStr)]

    with open(str(target[0]), 'w') as fp:
        includeGuard(fp, filename)

        for pair in info:
            line = '#define %s_' % NAME.upper() + pair[0]
            line += ' "%s"\n' % str(pair[1]) if pair[1] else '\n'
            fp.write(line)

        includeGuard(fp)

def buildDir(self, *paths):
    return os.path.join(self['BUILD_DIR'], *paths)

def libExistance(target, source, env):
    libFilename = str(env['LIBTARGET'][0])
    if not os.path.isfile(libFilename):
        raise Errors.StopError('%s not found. Compile it with/before the tests.' % libFilename)

SetOption('num_jobs', 4)
AddOption('--no-coverage', dest = 'withCoverage', action = 'store_false', default = True)
AddOption('--release', dest = 'release', action = 'store_true', default = False)
AddOption('--prefix', dest = 'prefix', nargs = 1, default = DEFAULT_PREFIX)
AddOption('--builddir', dest = 'buildDir', nargs = 1, default = DEFAULT_BUILDDIR)

release = GetOption('release') and not 'CFLAGS' in os.environ and not 'CXXFLAGS' in os.environ
withCoverage = False if release or 'CXXFLAGS' in os.environ else GetOption('withCoverage')

env = Environment(BUILD_DIR = GetOption('buildDir'))

env.AddMethod(buildDir)

env.Append(CFLAGS = ['-pedantic', '-Wall', '-Wextra', '-Wno-sign-compare', '-Wno-unused-label',
    '-Wno-unused-function', '-Wno-unneeded-internal-declaration'])
env.Append(CXXFLAGS = ['-std=c++98', '-pedantic', '-Wall', '-Wextra', '-Werror=conversion'])

if release:
    env.Append(CFLAGS = '-O2', CXXFLAGS = '-O2', CPPDEFINES = 'NDEBUG')
else:
    env.Append(CFLAGS = ['-O0', '-g3', '-ggdb'], CXXFLAGS = ['-O0', '-g3', '-ggdb'])

for key in ('CC', 'CXX', 'CFLAGS', 'CXXFLAGS'):
    if key in os.environ.keys():
        env[key] = os.environ.get(key)

libEnv = env.Clone()
testEnv = env.Clone()

libEnv.Replace(BUILD_DIR = env.buildDir('src'))
testEnv.Replace(BUILD_DIR = env.buildDir('test'))

libEnv.Append(BUILDERS = {
    'ConfigHeader': Builder(action = writeConfigHeader),
    'BuildInfo': Builder(action = writeBuildInfoHeader),
    'LibHeader': Builder(action = writeLibHeader)
    })

libEnv.VariantDir(libEnv.buildDir(), 'src')
libEnv.Append(WITH_DEBUG_STRINGS = not release)
libEnv.Append(WITH_UTF8 = True)
libEnv.Append(CPPPATH = libEnv.buildDir())
libEnv.Append(YACCFLAGS = '-d')

configHeader = libEnv.ConfigHeader(libEnv.buildDir('config.h'), None)
buildInfoHeader = libEnv.BuildInfo(libEnv.buildDir('buildinfo.h'), None)
libHeader = libEnv.LibHeader(libEnv.buildDir('%s.h' % NAME), None)

scanner = libEnv.buildDir('scanner.c')
parser = libEnv.buildDir('parser.c')
libEnv.CFile(scanner, 'src/scanner.l')
libEnv.CFile(parser, 'src/parser.y')

testEnv.VariantDir(testEnv.buildDir(), 'test')
testEnv.Append(CPPPATH = [libEnv.buildDir(), testEnv.buildDir()])
testEnv.Append(LIBS = ['CppUTest', 'tsym'])
testEnv.Append(RPATH = env.buildDir())
testEnv.Append(LIBPATH = env.buildDir())
testEnv.Append(LIBS = 'trlog')

libTarget = libEnv.SharedLibrary(env.buildDir(LIBNAME),
    Glob(libEnv.buildDir('*.cpp')) + [scanner, parser])

if withCoverage:
    libEnv.Append(CXXFLAGS = '--coverage')
    libEnv.AppendUnique(LIBS = 'gcov')
    Clean(libTarget, Glob(libEnv.buildDir('*.gcno')) + Glob(libEnv.buildDir('*.gcda')))

testTarget = testEnv.Program(env.buildDir(TEST_EXEC), Glob(testEnv.buildDir('*.cpp')))

# The following lines ensures that library and tests can be built with different CXXFLAGS. Due to
# the hard-coded removal of the dependency, its local existance has to be checked, otherwise the
# test executable might be linked against a globally installed version of the library.
testEnv.Append(LIBTARGET = libTarget)
testEnv.Ignore(testTarget, testEnv['LIBTARGET'])
testEnv.AddPreAction(testTarget, libExistance)

includeDir = os.path.join(GetOption('prefix'), 'include')
headerTargetDir = os.path.join(includeDir, NAME)
libDir = os.path.join(GetOption('prefix'), 'lib')
libPath = os.path.join(libDir, LIBNAME + Environment().subst('$SHLIBSUFFIX'))

installLib = libEnv.InstallAs(libPath, libTarget)
installHeader = libEnv.Install(headerTargetDir, [publicHeaderList(), libHeader])

for target in installHeader:
    libEnv.AddPostAction(target, Chmod('$TARGET', 0644))
for target in [GetOption('prefix'), headerTargetDir, libDir, includeDir, installLib]:
    libEnv.AddPostAction(target, Chmod('$TARGET', 0755))

uninstall = libEnv.Command('uninstall', None, Delete(FindInstalledFiles()))
libEnv.AddPostAction(uninstall, Delete(headerTargetDir))

Default([libTarget, testTarget, buildInfoHeader])
AlwaysBuild([configHeader, buildInfoHeader])
Alias('lib', [libTarget, buildInfoHeader])
Alias('test', testTarget)
Alias('install', [installHeader, installLib])

Help("""
Build targets control:\n
    [none]           shared library and unit tests
    'lib'            shared library
    'test'           unit tests only
    'install'        install library and headers
    'uninstall'      deinstall library and headers

Local options:\n
    --release        select default release compiler flags, strip debug helpers
    --no-coverage    don't add test coverage flags (only with default flags)
    --prefix=dir     installation location (default %s)
    --builddir=dir   build directory (default %s)

Compiler and compiler flags:\n
    Environment variables CC, CXX, CFLAGS and CXXFLAGS are taken into account.
    In their absence, defaults are provided (debug or release).
""" % (DEFAULT_PREFIX, DEFAULT_BUILDDIR), append = False)
